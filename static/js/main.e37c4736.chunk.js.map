{"version":3,"sources":["AlgorithmReducer.js","Maze.js","UtilityFuncs.js","Search.js","Cell/CellActions.js","Cell/Cell.js","Grid/Grid.js","PathFindingAlgos/AStarAlgorithm.js","PathFindingAlgos/DijkstrasAlgorithm.js","DataStructures/Queue.js","PathFindingAlgos/BreadthFirstSearch.js","PathFindingAlgos/BestFirstSearch.js","MazeAlgos/RecursiveDivision.js","Header/Header.js","App.js","index.js"],"names":["ALGO_ACTIONS","initialState","isSearching","isCreatingMaze","algoReducer","state","action","type","payload","console","error","mazeVars","mazeAlgo","varDispatch","a","searchVars","gridCl","clearEntireGrid","outlineGrid","then","catch","err","log","finally","timer","ms","Promise","resolve","setTimeout","rnd","min","max","Math","floor","random","rndEven","rndOdd","stopSearch","maxSearchTime","minSearchTime","pathAnimationTime","searchAnimationTime","retracePath","start","end","path","currentCell","push","parentCell","reverse","canCrossDiagonals","search","searching","endSearch","drawPath","i","length","cell","isOnPath","setCellRerender","rerender","reject","res","CELL_TYPES","cellIsStartOrEnd","posX","posY","grid","startCell","endCell","determineCellType","evt","mouseDown","cellTypeOnMouseDown","cellType","altKey","ctrlKey","x","y","closed","opened","changeCellType","compareFCost","b","comparison","fCost","hCost","compareGCost","gCost","compareHCost","Cell","heapIndex","getCellColor","Error","this","CellSquareState","props","useState","useEffect","rerenderCell","document","onmousedown","onmouseup","CellSquare","className","style","backgroundColor","onMouseMove","onMouseDown","onClick","assignFinishOrStart","maxY","maxX","initGrid","row","getMooreNeighbours","neighbours","cellIsInGrid","getVonNeumannNeighbours","forEach","clearWalls","resetCellsForSearch","cellA","cellB","dstX","abs","dstY","animTime","outLine","Grid","id","map","AStarSearch","resetForSearch","Heap","require","openHeap","closedSet","Set","foundPath","empty","pop","neighbour","has","distCurrentToNeighbour","calculateDistance","newDistStartToNeighbour","updateItem","add","dijkstrasSearch","unvisitedHeap","initHeap","unVisitedNeighbours","filter","tempCurrentCell","distNeighbourToCurrent","Number","MAX_SAFE_INTEGER","heap","Queue","items","head","tail","item","Object","values","indexOf","size","result","key","breadthFirstSearch","unvisitedQueue","initGCosts","enQueue","deQueue","bestFirstSearch","ORIENTATIONS","startRecursiveDivision","divide","chooseOrientation","leftBound","upperBound","rightBound","lowerBound","horizSpace","vertSpace","orientation","findStart","isHorizontalCut","xStartIdx","yStartIdx","choosePassage","xPassageIdx","yPassageIdx","wallDist","dirX","dirY","drawWall","xWallIdx","yWallIdx","Header","useReducer","dispatch","setCanCrossDiagonals","animationInterval","setAnimationInterval","missingCell","setMissingCell","executePathFinding","algorithm","pathFind","value","onChange","target","interval","num","parseFloat","checked","createMaze","onClose","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.e37c4736.chunk.js","sourcesContent":["export const ALGO_ACTIONS = {\r\n  IS_SEARCHING: \"IS_SEARCHING\",\r\n  IS_CREATING_MAZE: \"IS_CREATING_MAZE\",\r\n};\r\n// this state represents( but does not manage) the state of the algorithms so the header can change accordingly\r\nexport const initialState = {\r\n  isSearching: false,\r\n  isCreatingMaze: false,\r\n};\r\n\r\nexport default function algoReducer(state, action) {\r\n  switch (action.type) {\r\n    case ALGO_ACTIONS.IS_SEARCHING:\r\n      return {\r\n        ...state,\r\n        isSearching: action.payload,\r\n      };\r\n    case ALGO_ACTIONS.IS_CREATING_MAZE:\r\n      return {\r\n        ...state,\r\n        isCreatingMaze: action.payload,\r\n      };\r\n    default:\r\n      console.error(\"no matching action types\");\r\n  }\r\n}\r\n","import { ALGO_ACTIONS } from \"./AlgorithmReducer\";\r\nimport { gridCl } from \"./Grid/Grid\";\r\nimport { searchVars } from \"./Search\";\r\n\r\nexport const mazeVars = { isCreatingMaze: false };\r\n\r\n/* Outlines and generates a maze using a given algorithm.\r\n\r\n@param {Function} mazeAlgo - the maze algorithm to run\r\n@param {Function} varDispatch - the dispatch function used to change the state of the Header component\r\n*/\r\nexport async function createMaze(mazeAlgo, varDispatch) {\r\n  if (!mazeVars.isCreatingMaze && !searchVars.isSearching) {\r\n    mazeVars.isCreatingMaze = true;\r\n    varDispatch({ type: ALGO_ACTIONS.IS_CREATING_MAZE, payload: true });\r\n\r\n    gridCl.clearEntireGrid();\r\n\r\n    await gridCl\r\n      // run outline grid promise\r\n      .outlineGrid(1)\r\n      .then(() => {\r\n        // if outline grid had no error run maze algorithm promise\r\n        mazeAlgo()\r\n          .catch((err) => {\r\n            // run if the promise was rejected\r\n            console.log(\"Error running maze algorithm\");\r\n            console.error(err);\r\n          })\r\n          .finally(() => {\r\n            // no matter the outcome run this\r\n            mazeVars.isCreatingMaze = false;\r\n            varDispatch({\r\n              type: ALGO_ACTIONS.IS_CREATING_MAZE,\r\n              payload: false,\r\n            });\r\n          });\r\n      })\r\n      .catch((err) => {\r\n        // if the outline grid promise was rejected log the error\r\n        console.error(err);\r\n      });\r\n  }\r\n}\r\n","export const timer = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\nexport const getKeyByValue = (object, value) => {\r\n  return Object.keys(object).find((key) => object[key] === value);\r\n};\r\n\r\n/* Returns a random number within a range.\r\n\r\n  @param {number} min - minimum random number (inclusive)\r\n  @param {number} max - maximum random number (inclusive)\r\n*/\r\nexport const rnd = (min, max) => {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n};\r\n\r\n/* Returns a random even number within a range of 2 even numbers.\r\n\r\n  @param {number} min - minimum EVEN random number (inclusive)\r\n  @param {number} max - maximum EVEN random number (inclusive)\r\n*/\r\nexport const rndEven = (min, max) => {\r\n  let randomNum = Math.floor(rnd(min, max) / 2) * 2;\r\n  return randomNum;\r\n};\r\n\r\n/* Returns a random odd number between a range of 2 odd numbers.\r\n\r\n  @param {number} min - minimum ODD random number (inclusive)\r\n  @param {number} max - maximum ODD random number (inclusive)\r\n*/\r\nexport const rndOdd = (min, max) => {\r\n  max = max % 2 === 0 ? max : max - 1;\r\n  let randomNum = Math.floor(rnd(min, max) / 2) * 2 + 1;\r\n  return randomNum;\r\n};\r\n\r\nexport const clamp = (num, min, max) => Math.min(Math.max(num, min), max);\r\n","import { ALGO_ACTIONS } from \"./AlgorithmReducer\";\r\nimport { mazeVars } from \"./Maze\";\r\nimport { timer } from \"./UtilityFuncs\";\r\n\r\nexport const searchVars = {\r\n  isSearching: false,\r\n  stopSearch: false,\r\n  maxSearchTime: 3000,\r\n  minSearchTime: 1,\r\n  pathAnimationTime: 10,\r\n  searchAnimationTime: 15,\r\n};\r\n\r\nexport function retracePath(start, end) {\r\n  const path = [];\r\n  var currentCell = end;\r\n\r\n  while (currentCell !== start) {\r\n    path.push(currentCell);\r\n    currentCell = currentCell.parentCell;\r\n  }\r\n  path.reverse();\r\n\r\n  return path;\r\n}\r\n\r\n/*Starts a given pathfinding algorithm and draws the path if found.\r\n\r\n  @param {Function} varDispatch - dispatch function used to change state for the Header component\r\n  @param {Function} searching - the searching algorithm to run\r\n*/\r\nexport async function pathFind(canCrossDiagonals, varDispatch, search) {\r\n  if (searchVars.isSearching || mazeVars.isCreatingMaze) {\r\n    return;\r\n  }\r\n\r\n  searchVars.isSearching = true;\r\n  varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: true });\r\n\r\n  // execute promise to search that should resolve a path\r\n  var path = await searching(canCrossDiagonals, search).catch((err) => {\r\n    // if the promise was rejected the log the error\r\n    console.log(\"error in search\");\r\n    console.error(err);\r\n  });\r\n  if (path == null) {\r\n    endSearch(varDispatch);\r\n    return;\r\n  }\r\n  await drawPath(path).catch((err) => {\r\n    console.error(err);\r\n  });\r\n\r\n  endSearch(varDispatch);\r\n}\r\n\r\n/*Ends the searching algorithm and resets state.\r\n\r\n@param {Function} varDispatch - dispatch function used to change state for the Header component\r\n*/\r\nfunction endSearch(varDispatch) {\r\n  searchVars.isSearching = false;\r\n  searchVars.stopSearch = false;\r\n  varDispatch({ type: ALGO_ACTIONS.IS_SEARCHING, payload: false });\r\n}\r\n\r\nasync function drawPath(path) {\r\n  for (let i = 0; i < path.length; i++) {\r\n    const cell = path[i];\r\n    cell.isOnPath = true;\r\n    cell.setCellRerender((rerender) => !rerender);\r\n    await timer(searchVars.pathAnimationTime);\r\n  }\r\n}\r\n\r\nfunction searching(canCrossDiagonals, search) {\r\n  return new Promise((resolve, reject) => {\r\n    search(canCrossDiagonals)\r\n      .then((res) => {\r\n        // get the path as 'res'\r\n        resolve(res);\r\n      })\r\n      .catch((err) => {\r\n        console.log(\"Woops\");\r\n        reject(err);\r\n      });\r\n  });\r\n}\r\n","import { gridCl } from \"../Grid/Grid\";\r\nimport { searchVars } from \"../Search\";\r\n\r\nexport const CELL_TYPES = {\r\n  EMPTY: 0,\r\n  START: 1,\r\n  END: 2,\r\n  OBSTACLE: 3,\r\n};\r\n// assigns the start and end cells depending on which cell you click and whether Ctrl or Alt is down.\r\nexport const assignFinishOrStart = (evt, cell) => {\r\n  if (searchVars.isSearching) {\r\n    return;\r\n  }\r\n  if (evt.altKey) {\r\n    if (cell.cellType === CELL_TYPES.END) {\r\n      gridCl.endCell = null;\r\n      changeCellType(cell, CELL_TYPES.EMPTY);\r\n    } else {\r\n      if (cell.cellType === CELL_TYPES.START) {\r\n        gridCl.startCell = null;\r\n      }\r\n      if (gridCl.endCell != null) {\r\n        changeCellType(gridCl.endCell, CELL_TYPES.EMPTY);\r\n      }\r\n      changeCellType(cell, CELL_TYPES.END);\r\n      gridCl.endCell = cell;\r\n    }\r\n  } else if (evt.ctrlKey) {\r\n    if (cell.cellType === CELL_TYPES.START) {\r\n      gridCl.startCell = null;\r\n      changeCellType(cell, CELL_TYPES.EMPTY);\r\n    } else {\r\n      if (cell.cellType === CELL_TYPES.END) {\r\n        gridCl.endCell = null;\r\n      }\r\n\r\n      if (gridCl.startCell != null) {\r\n        changeCellType(gridCl.startCell, CELL_TYPES.EMPTY);\r\n      }\r\n      changeCellType(cell, CELL_TYPES.START);\r\n      gridCl.startCell = cell;\r\n    }\r\n  }\r\n};\r\n\r\nexport const cellIsStartOrEnd = (posX, posY) => {\r\n  return (\r\n    gridCl.grid[posY][posX] === gridCl.startCell ||\r\n    gridCl.grid[posY][posX] === gridCl.endCell\r\n  );\r\n};\r\n\r\n// determines the cell type when the mouse is down/hovering over the given cell\r\nexport const determineCellType = (\r\n  evt,\r\n  mouseDown,\r\n  cellTypeOnMouseDown,\r\n  cell\r\n) => {\r\n  if (mouseDown) {\r\n    if (cellTypeOnMouseDown === -1) return;\r\n    const cellType =\r\n      cellTypeOnMouseDown === CELL_TYPES.EMPTY\r\n        ? CELL_TYPES.OBSTACLE\r\n        : CELL_TYPES.EMPTY;\r\n\r\n    if (cell.cellType !== cellType && !evt.altKey && !evt.ctrlKey) {\r\n      if (cellIsStartOrEnd(cell.x, cell.y)) {\r\n        return;\r\n      }\r\n      if ((cell.closed || cell.opened) && searchVars.isSearching) {\r\n        return;\r\n      }\r\n      changeCellType(cell, cellType);\r\n    }\r\n  }\r\n};\r\n\r\nconst changeCellType = (cell, cellType) => {\r\n  cell.cellType = cellType;\r\n  cell.setCellRerender((rerender) => !rerender);\r\n};\r\n\r\n// compare cells by fCost and if needed by hCost\r\nexport function compareFCost(a, b) {\r\n  var comparison = a.fCost() < b.fCost() ? -1 : 1;\r\n\r\n  if (a.fCost() === b.fCost()) {\r\n    comparison = a.hCost < b.hCost ? -1 : 0;\r\n  }\r\n\r\n  return comparison;\r\n}\r\n\r\n// compare cells by gCost\r\nexport function compareGCost(a, b) {\r\n  var comparison = a.gCost < b.gCost ? -1 : 1;\r\n  if (a.gCost === b.gCost) {\r\n    comparison = 0;\r\n  }\r\n  return comparison;\r\n}\r\n\r\n// compare cells by hCost\r\nexport function compareHCost(a, b) {\r\n  var comparison = a.hCost < b.hCost ? -1 : 1;\r\n  if (a.hCost === b.hCost) {\r\n    comparison = 0;\r\n  }\r\n  return comparison;\r\n}\r\n","import React, { useEffect, useState } from \"react\";\r\nimport {\r\n  assignFinishOrStart,\r\n  determineCellType,\r\n  CELL_TYPES,\r\n} from \"./CellActions\";\r\nimport \"./cell.css\";\r\n\r\n/*The Grid\r\nThe class that handles the color, costs, and states of a cell.\r\n */\r\nexport default class Cell {\r\n  setCellRerender = null;\r\n  isOnPath = false;\r\n  opened = false;\r\n  closed = false;\r\n  cellType = CELL_TYPES.EMPTY;\r\n\r\n  // the cost from this cell to the start cell\r\n  gCost = 0;\r\n\r\n  // the cost from this cell to the end cell\r\n  hCost = 0;\r\n\r\n  // the total cost\r\n  fCost = () => this.hCost + this.gCost;\r\n\r\n  heapIndex = -1;\r\n\r\n  // contains another Cell instance used for retracing a path\r\n  parentCell = null;\r\n\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  getCellColor = () => {\r\n    if (\r\n      (!this.opened && !this.isOnPath && !this.closed) ||\r\n      this.cellType !== 0\r\n    ) {\r\n      switch (this.cellType) {\r\n        case CELL_TYPES.EMPTY:\r\n          return \"rgba(221, 221, 221, 0.603)\";\r\n        case CELL_TYPES.START:\r\n          return \"green\";\r\n        case CELL_TYPES.END:\r\n          return \"red\";\r\n        case CELL_TYPES.OBSTACLE:\r\n          return \"black\";\r\n        default:\r\n          throw new Error(\"Out of range exception\");\r\n      }\r\n    } else if (this.isOnPath) {\r\n      return \"lightskyblue\";\r\n    } else if (this.closed) {\r\n      return \"lightgray\";\r\n    } else if (this.opened) {\r\n      return \"lightgreen\";\r\n    }\r\n  };\r\n}\r\n\r\nvar mouseDown = false;\r\nvar cellTypeOnMouseDown = -1;\r\n\r\nexport function CellSquareState(props) {\r\n  const { cell } = props;\r\n  const [, setCellRerender] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (cell.rerenderCell == null) {\r\n      cell.setCellRerender = setCellRerender;\r\n    }\r\n  }, [cell]);\r\n\r\n  document.onmousedown = () => (mouseDown = true);\r\n\r\n  document.onmouseup = () => {\r\n    mouseDown = false;\r\n    cellTypeOnMouseDown = -1;\r\n  };\r\n\r\n  return <CellSquare state={{ cell }} />;\r\n}\r\n\r\nfunction CellSquare({ state }) {\r\n  const { cell } = state;\r\n  return (\r\n    <div\r\n      className={\"cell\"}\r\n      style={{ backgroundColor: cell.getCellColor() }}\r\n      onMouseMove={(evt) =>\r\n        determineCellType(evt, mouseDown, cellTypeOnMouseDown, cell)\r\n      }\r\n      onMouseDown={(evt) => {\r\n        cellTypeOnMouseDown = cell.cellType;\r\n        determineCellType(evt, true, cellTypeOnMouseDown, cell);\r\n      }}\r\n      onClick={(evt) => assignFinishOrStart(evt, cell)}\r\n    ></div>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport Cell, { CellSquareState } from \"../Cell/Cell\";\r\nimport { CELL_TYPES, cellIsStartOrEnd } from \"../Cell/CellActions\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport \"./grid.css\";\r\n/*The Grid\r\nThe GridCl class contains all the cells that will be used to path find as well as the start and end cell.\r\nThe dimensions should be odd to work with recursive division.\r\n\r\nIt contains functions that manage the state of the grid.\r\n */\r\n\r\nclass GridCl {\r\n  grid = [];\r\n  startCell = null;\r\n  endCell = null;\r\n\r\n  // dimensions must be odd to work with recursive division\r\n  maxY = 27;\r\n  maxX = 61;\r\n\r\n  constructor() {\r\n    this.initGrid();\r\n  }\r\n  initGrid = () => {\r\n    for (let y = 0; y < this.maxY; y++) {\r\n      var row = [];\r\n      for (let x = 0; x < this.maxX; x++) {\r\n        row.push(new Cell(x, y));\r\n      }\r\n      this.grid.push(row);\r\n    }\r\n\r\n    // place the start node a quarter away from the left bound\r\n    let startCell =\r\n      this.grid[Math.floor(this.maxY / 2)][Math.floor(this.maxX / 4)];\r\n\r\n    // place the end node a quarter away from the right bound\r\n    let endCell =\r\n      this.grid[Math.floor(this.maxY / 2)][\r\n        Math.floor(this.maxX - this.maxX / 4)\r\n      ];\r\n\r\n    startCell.cellType = CELL_TYPES.START;\r\n    endCell.cellType = CELL_TYPES.END;\r\n\r\n    this.startCell = startCell;\r\n    this.endCell = endCell;\r\n  };\r\n\r\n  /* get the 8 or less surrounding neighbours of a cell at indices posX and posY\r\n\r\n    does not retrieve the neighbour if it is not in the grid\r\n\r\n    @param {number} posX - the x-index of a given cell whose neighbours we are checking\r\n    @param {number} posY - the y-index of a given cell whose neighbours we are checking\r\n\r\n    @return {Array} neighbours - contains up to 8 surrounding neighbours\r\n   */\r\n  getMooreNeighbours = (posX, posY) => {\r\n    const neighbours = [];\r\n    for (var y = -1; y <= 1; y++) {\r\n      for (var x = -1; x <= 1; x++) {\r\n        if (x === 0 && y === 0) {\r\n          continue;\r\n        }\r\n        if (!this.cellIsInGrid(posX + x, posY + y)) {\r\n          continue;\r\n        }\r\n\r\n        neighbours.push(this.grid[posY + y][posX + x]);\r\n      }\r\n    }\r\n\r\n    return neighbours;\r\n  };\r\n\r\n  /* get top, left, right, and down neighbours of a cell at indices posX and posY\r\n\r\n    Does not retrieve the neighbour if it is not in the grid\r\n\r\n    @param {number} posX - the x-index of a given cell whose neighbours we are checking\r\n    @param {number} posY - the y-index of a given cell whose neighbours we are checking\r\n\r\n    @return {Array} neighbours - contains up to 4 surrounding neighbours\r\n   */\r\n  getVonNeumannNeighbours = (posX, posY) => {\r\n    const neighbours = [];\r\n\r\n    if (this.cellIsInGrid(posX - 1, posY)) {\r\n      neighbours.push(this.grid[posY][posX - 1]);\r\n    }\r\n    if (this.cellIsInGrid(posX + 1, posY)) {\r\n      neighbours.push(this.grid[posY][posX + 1]);\r\n    }\r\n    if (this.cellIsInGrid(posX, posY - 1)) {\r\n      neighbours.push(this.grid[posY - 1][posX]);\r\n    }\r\n    if (this.cellIsInGrid(posX, posY + 1)) {\r\n      neighbours.push(this.grid[posY + 1][posX]);\r\n    }\r\n\r\n    return neighbours;\r\n  };\r\n\r\n  /* Checks if a cell is in the grid\r\n\r\n  @param {number} x - the x-index of a cell\r\n  @param {number} y - the y-index of a cell\r\n\r\n  @returns {boolean} if given cell index at x and y is contained within the 2d array */\r\n  cellIsInGrid = (x, y) => {\r\n    if (x < 0 || y < 0 || x >= this.maxX || y >= this.maxY) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  };\r\n\r\n  // revert every single cell back to empty other then the start and end cells\r\n  clearEntireGrid = () => {\r\n    this.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        var rerender = false;\r\n        if (cell.opened) {\r\n          cell.opened = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.isOnPath) {\r\n          cell.isOnPath = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.closed) {\r\n          cell.closed = false;\r\n          rerender = true;\r\n        }\r\n        if (\r\n          cell.cellType !== CELL_TYPES.EMPTY &&\r\n          cell.cellType !== CELL_TYPES.START &&\r\n          cell.cellType !== CELL_TYPES.END\r\n        ) {\r\n          cell.cellType = CELL_TYPES.EMPTY;\r\n          rerender = true;\r\n        }\r\n        if (rerender) {\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  resetForSearch() {\r\n    return new Promise((resolve, reject) => {\r\n      // reset cells\r\n      this.resetCellsForSearch()\r\n        .then(() => {\r\n          // if there were no errors resolve the promise as true\r\n          resolve(true);\r\n        })\r\n        .catch((err) => {\r\n          // if there was an error reject the promise\r\n          reject(err);\r\n        });\r\n    });\r\n  }\r\n\r\n  // reset any opened, closed, or onPath cells\r\n  async resetCellsForSearch() {\r\n    gridCl.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        var rerender = false;\r\n        if (cell.opened) {\r\n          cell.opened = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.isOnPath) {\r\n          cell.isOnPath = false;\r\n          rerender = true;\r\n        }\r\n        if (cell.closed) {\r\n          cell.closed = false;\r\n          rerender = true;\r\n        }\r\n        if (rerender) {\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  clearWalls = () => {\r\n    this.grid.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        if (cell.cellType === CELL_TYPES.OBSTACLE) {\r\n          cell.cellType = CELL_TYPES.EMPTY;\r\n          cell.setCellRerender((rerender) => !rerender);\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  /* Calculates the distance between to cells\r\n\r\n  distance for diagonal algorithms is calculated using octile distance.\r\n  distance for non-diagonal algorithms is calculated using manhattan distance.\r\n\r\n  @param {Object} cellA - the first cell\r\n  @param {Object} cellB - the second cell\r\n  @param {boolean} canCrossDiagonals - whether the cellA can cross diagonals to get to cellB vice-versa\r\n\r\n  @return {float} the distance between cellA and cellB\r\n  */\r\n  calculateDistance(cellA, cellB, canCrossDiagonals) {\r\n    if (canCrossDiagonals) {\r\n      var dstX = Math.abs(cellA.x - cellB.x);\r\n      var dstY = Math.abs(cellA.y - cellB.y);\r\n\r\n      if (dstX > dstY) {\r\n        return 14 * dstY + 10 * (dstX - dstY);\r\n      }\r\n\r\n      return 14 * dstX + 10 * (dstY - dstX);\r\n    } else {\r\n      return Math.abs(cellA.x - cellB.x) + Math.abs(cellA.y - cellB.y);\r\n    }\r\n  }\r\n\r\n  outlineGrid(animTime) {\r\n    return new Promise((resolve, reject) =>\r\n      this.outLine(animTime)\r\n        .then((res) => {\r\n          resolve(res);\r\n        })\r\n        .catch((err) => {\r\n          reject(err);\r\n        })\r\n    );\r\n  }\r\n\r\n  /*Outlines the grid with a cell of type Obstacle\r\n\r\n  @param {float} animTime - the animation time to wait before drawing the next cell\r\n  */\r\n  async outLine(animTime) {\r\n    for (let y = 0; y < this.maxY; y++) {\r\n      if (!cellIsStartOrEnd(0, y)) {\r\n        // outlines left wall\r\n        this.grid[y][0].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[y][0].setCellRerender((rerender) => !rerender);\r\n      }\r\n      if (!cellIsStartOrEnd(this.maxX - 1, y)) {\r\n        // outlines right wall\r\n        this.grid[y][this.maxX - 1].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[y][this.maxX - 1].setCellRerender((rerender) => !rerender);\r\n      }\r\n      await timer(animTime);\r\n    }\r\n    for (let x = 0; x < this.maxX; x++) {\r\n      if (!cellIsStartOrEnd(x, 0)) {\r\n        // outlines top wall\r\n        this.grid[0][x].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[0][x].setCellRerender((rerender) => !rerender);\r\n      }\r\n      if (!cellIsStartOrEnd(x, this.maxY - 1)) {\r\n        // outlines bottom wall\r\n        this.grid[this.maxY - 1][x].cellType = CELL_TYPES.OBSTACLE;\r\n        this.grid[this.maxY - 1][x].setCellRerender((rerender) => !rerender);\r\n      }\r\n      await timer(animTime);\r\n    }\r\n  }\r\n}\r\n\r\nexport const gridCl = new GridCl();\r\n\r\nfunction Grid() {\r\n  return (\r\n    <section id=\"grid\">\r\n      {gridCl.grid.map((row) =>\r\n        row.map((cell) => {\r\n          return <CellSquareState cell={cell} key={cell.x + \" \" + cell.y} />;\r\n        })\r\n      )}\r\n    </section>\r\n  );\r\n}\r\n\r\nexport default Grid;\r\n","import { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareFCost } from \"../Cell/CellActions\";\r\nimport { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\n\r\n/*A* Search Algorithm\r\n\r\nUses a min heap to compare fCosts/hCosts to find the next cell\r\nto check.\r\n\r\nA cell is considered closed/visited once its neighbours have been checked.\r\n\r\nAlways finds a shortest path.\r\n\r\n@param {boolean} canCrossDiagonals - whether the path should be able to cross diagonals\r\n@returns {Array} path - The path or null if no path is found\r\n\r\n*/\r\nexport default async function AStarSearch(canCrossDiagonals) {\r\n  let success = await gridCl.resetForSearch().catch((err) => {\r\n    // if the promise was rejected log the error\r\n    console.error(err);\r\n  });\r\n\r\n  // if the reset for search promise did not resolve true leave\r\n  if (!success) {\r\n    return;\r\n  }\r\n\r\n  var Heap = require(\"heap\");\r\n\r\n  // instantiate a heap that will pop the most optimal cell according to FCost\r\n  const openHeap = new Heap(compareFCost);\r\n\r\n  const closedSet = new Set();\r\n\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n  openHeap.push(startCell);\r\n\r\n  var foundPath = false;\r\n\r\n  while (!openHeap.empty()) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n\r\n    // pop the next optimal cell for the path\r\n    const currentCell = openHeap.pop();\r\n\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n    var neighbours = [];\r\n\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      const neighbour = neighbours[i];\r\n      if (\r\n        neighbour.cellType === CELL_TYPES.OBSTACLE ||\r\n        closedSet.has(neighbour)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      const distCurrentToNeighbour = gridCl.calculateDistance(\r\n        currentCell,\r\n        neighbour,\r\n        canCrossDiagonals\r\n      );\r\n\r\n      // calculate the distance from the start to the neighbour through the current cell\r\n      const newDistStartToNeighbour =\r\n        currentCell.gCost + distCurrentToNeighbour;\r\n\r\n      // if the gCost is better through the current cell then it was for a previous cell\r\n      // then there is a better path to get to this neighbour.\r\n      // if the neighbour was never opened then we need to assign its costs\r\n      if (newDistStartToNeighbour < neighbour.gCost || !neighbour.opened) {\r\n        neighbour.gCost = newDistStartToNeighbour;\r\n\r\n        // assign parent cell to this current cell as it has its lowest known cost through this current cell\r\n        neighbour.parentCell = currentCell;\r\n\r\n        if (!neighbour.opened) {\r\n          // calculate hCost which doesn't change once opened unlike gCost\r\n          neighbour.hCost = gridCl.calculateDistance(\r\n            neighbour,\r\n            endCell,\r\n            canCrossDiagonals\r\n          );\r\n\r\n          // add to the opened heap as this neighbour may be the next optimal cell\r\n          openHeap.push(neighbour);\r\n          neighbour.opened = true;\r\n\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n        } else {\r\n          // since it's in the heap and gCost changed, update position in heap\r\n          openHeap.updateItem(neighbour);\r\n        }\r\n      }\r\n    }\r\n\r\n    // this current cell is closed because its neighbours have been checked\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    closedSet.add(currentCell);\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareGCost } from \"../Cell/CellActions\";\r\n\r\n/* Dijkstras Search Algorithm\r\n\r\nUses a min heap that compares gCosts to find the next cell to \r\ncheck.\r\n\r\nA cell is considered closed/visited once its neighbours have been checked.\r\n\r\nAlways finds a shortest path.\r\n\r\n@param {boolean} canCrossDiagonals - whether the path should be able to cross diagonals\r\n@returns {Array} path - The path or null if no path is found\r\n\r\n*/\r\nexport default async function dijkstrasSearch(canCrossDiagonals) {\r\n  let success = await gridCl.resetForSearch().catch((err) => {\r\n    // if the promise was rejected log the error\r\n    console.error(err);\r\n  });\r\n\r\n  // if the reset for search promise did not resolve true leave\r\n  if (!success) {\r\n    return;\r\n  }\r\n\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  var Heap = require(\"heap\");\r\n\r\n  const unvisitedHeap = new Heap(compareGCost);\r\n\r\n  // reset gCosts of every node before adding it to the heap\r\n  await initHeap(unvisitedHeap);\r\n\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n\r\n  startCell.gCost = 0;\r\n  unvisitedHeap.updateItem(startCell);\r\n\r\n  var currentCell = unvisitedHeap.pop();\r\n  var neighbours = [];\r\n  var foundPath = false;\r\n\r\n  while (!unvisitedHeap.empty()) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    // we cannot include cells that are already on the path\r\n    const unVisitedNeighbours = neighbours.filter((x) => !x.closed);\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    unVisitedNeighbours.forEach((neighbour) => {\r\n      const distNeighbourToCurrent = gridCl.calculateDistance(\r\n        tempCurrentCell,\r\n        neighbour,\r\n        canCrossDiagonals\r\n      );\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        // calculate the distance from the start to the neighbour through the current cell\r\n        const newDistStartToNeighbour =\r\n          tempCurrentCell.gCost + distNeighbourToCurrent;\r\n\r\n        // if the gCost is better through the current cell then it was for a previous cell\r\n        if (newDistStartToNeighbour < neighbour.gCost) {\r\n          neighbour.gCost = newDistStartToNeighbour;\r\n\r\n          // set parent cell to the current cell for path retracing\r\n          neighbour.parentCell = tempCurrentCell;\r\n\r\n          neighbour.opened = true;\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n\r\n          // since gCost has updated we must update its position in the heap\r\n          unvisitedHeap.updateItem(neighbour);\r\n        }\r\n      }\r\n    });\r\n\r\n    // close this current cell as we have checked its neighbours\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n\r\n    // pop the next cell with the lowest gCost to be the current\r\n    currentCell = unvisitedHeap.pop();\r\n\r\n    // if the next cell optimal cell has not changed in gCost it means there is no path\r\n    if (currentCell.gCost === Number.MAX_SAFE_INTEGER) {\r\n      // needs this break because all cells are given to dijkstras heap on initialization\r\n      break;\r\n    }\r\n  }\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  }\r\n  console.log(\"no path found\");\r\n}\r\n\r\n/* Resets the cells to have the maximum gCost before adding them to the heap.\r\n\r\nThis is done so every cell can update its gCost during dijkstras.\r\n\r\n@param {Heap} heap - the heap to add cells to after gCost reset\r\n@returns {Promise} - resolves the action of reseting gCosts and adding to heap\r\n\r\n*/\r\nfunction initHeap(heap) {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          cell.gCost = Number.MAX_SAFE_INTEGER;\r\n          heap.push(cell);\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","/*Queue\r\nData structure that follows FIFO\r\n */\r\n\r\nexport default class Queue {\r\n  items = {};\r\n  head = 0;\r\n  tail = 0;\r\n\r\n  /*enqueues a given item with O(1) time complexity\r\n\r\n  @param {any} item - an item to add to the queue\r\n  */\r\n  enQueue(item) {\r\n    this.items[this.tail] = item;\r\n    this.tail++;\r\n  }\r\n  contains(item) {\r\n    return Object.values(this.items).indexOf(item) > -1 ? true : false;\r\n  }\r\n\r\n  // dequeues with O(1) time complexity\r\n  deQueue() {\r\n    if (this.size() <= 0) return undefined;\r\n\r\n    // get the item at the start of the queue\r\n    var item = this.items[this.head];\r\n\r\n    delete this.items[this.head];\r\n\r\n    // now there are no items at the head key so we must increment it to point to the next head\r\n    this.head++;\r\n\r\n    if (this.head === this.tail) {\r\n      this.head = 0;\r\n      this.tail = 0;\r\n    }\r\n\r\n    return item;\r\n  }\r\n\r\n  size() {\r\n    return this.tail - this.head;\r\n  }\r\n\r\n  peek() {\r\n    return this.items[this.head];\r\n  }\r\n\r\n  print() {\r\n    var result = [];\r\n    for (let key in this.items) {\r\n      result.push(this.items[key]);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\nimport Queue from \"../DataStructures/Queue\";\r\n\r\n/* Breadth First Search Algorithm\r\n\r\nStarts at the root of a tree and searches from each neighbouring \r\nnode at present depth before moving into the next level of depth.\r\n\r\nUses a Queue to choose the next cell to check.\r\nUses gCost to assign parent cells for retracing path.\r\nUses the boolean var 'opened' to determine whether a cell is in the queue.\r\n\r\nA cell is considered closed/visited once its neighbours have been checked.\r\n\r\nAlways finds a shortest path.\r\n\r\n@param {boolean} canCrossDiagonals - whether the path should be able to cross diagonals\r\n@returns {Array} path - The path or null if no path is found\r\n\r\n*/\r\n\r\nexport default async function breadthFirstSearch(canCrossDiagonals) {\r\n  let success = await gridCl.resetForSearch().catch((err) => {\r\n    // if the promise was rejected log the error\r\n    console.error(err);\r\n  });\r\n\r\n  // if the reset for search promise did not resolve true leave\r\n  if (!success) {\r\n    return;\r\n  }\r\n\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  const unvisitedQueue = new Queue();\r\n  await initGCosts();\r\n\r\n  startCell.parentCell = startCell;\r\n\r\n  var currentCell = null;\r\n\r\n  var neighbours = [];\r\n\r\n  startCell.opened = true;\r\n  startCell.gCost = 0;\r\n\r\n  unvisitedQueue.enQueue(startCell);\r\n  var foundPath = false;\r\n\r\n  while (unvisitedQueue.size() > 0) {\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    currentCell = unvisitedQueue.deQueue();\r\n\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    const unVisitedNeighbours = neighbours.filter((x) => !x.closed);\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    for (let i = 0; i < unVisitedNeighbours.length; i++) {\r\n      var neighbour = unVisitedNeighbours[i];\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        if (!neighbour.closed && !neighbour.opened) {\r\n          // add to the unvisited Queue if its not already been in the queue\r\n          unvisitedQueue.enQueue(neighbour);\r\n        }\r\n        const distCurrentToNeighbour = gridCl.calculateDistance(\r\n          tempCurrentCell,\r\n          neighbour,\r\n          canCrossDiagonals\r\n        );\r\n\r\n        // calculate the new distance from start to neighbour through the current cell\r\n        const newDistStartToNeighbour =\r\n          tempCurrentCell.gCost + distCurrentToNeighbour;\r\n\r\n        // if the gCost is better through the current cell then it was for a previous cell\r\n        if (newDistStartToNeighbour < neighbour.gCost) {\r\n          neighbour.gCost = newDistStartToNeighbour;\r\n\r\n          // assign parent cell to current cell for path retracing\r\n          neighbour.parentCell = tempCurrentCell;\r\n\r\n          neighbour.opened = true;\r\n          neighbour.setCellRerender((rerender) => !rerender);\r\n        }\r\n      }\r\n    }\r\n\r\n    // current cell has been visited\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    console.log(\"no path found\");\r\n  }\r\n}\r\n\r\nfunction initGCosts() {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          // initialize all the gCosts to be as large as possible as none have been visited yet\r\n          cell.gCost = Number.MAX_SAFE_INTEGER;\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","import { searchVars, retracePath } from \"../Search\";\r\nimport { timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { CELL_TYPES, compareHCost } from \"../Cell/CellActions\";\r\n\r\n/* Best First Search Algorithm\r\n\r\nUses a min heap that compares hCosts to find the next cell to check.\r\n\r\nA cell is considered closed/visited once its neighbours have been checked.\r\n\r\nBecause BFS is a greedy algorithm it only finds the locally optimal solution \r\neach time when picking the next cell to travel too. This means it does not always find the shortest path.\r\n\r\nDue to BFS only checking the heuristic cost it will attempt to move straight to the end node without\r\ntaking account a better alternate path due to obstructions. This is shown when unlike the other algorithms\r\nBFS does not recalculate a new distance through the current cell.\r\n\r\n@param {boolean} canCrossDiagonals - whether the path should be able to cross diagonals\r\n@returns {Array} path - The path or null if no path is found\r\n\r\n*/\r\n\r\nexport default async function bestFirstSearch(canCrossDiagonals) {\r\n  let success = await gridCl.resetForSearch().catch((err) => {\r\n    // if the promise was rejected log the error\r\n    console.error(err);\r\n  });\r\n\r\n  // if the reset for search promise did not resolve true leave\r\n  if (!success) {\r\n    return;\r\n  }\r\n\r\n  const startCell = gridCl.startCell;\r\n  const endCell = gridCl.endCell;\r\n\r\n  var Heap = require(\"heap\");\r\n\r\n  const unvisitedHeap = new Heap(compareHCost);\r\n\r\n  await initHeap(unvisitedHeap);\r\n\r\n  startCell.parentCell = startCell;\r\n  startCell.opened = true;\r\n\r\n  startCell.gCost = 0;\r\n  startCell.hCost = gridCl.calculateDistance(\r\n    startCell,\r\n    endCell,\r\n    canCrossDiagonals\r\n  );\r\n  unvisitedHeap.updateItem(startCell);\r\n\r\n  var neighbours = [];\r\n  var foundPath = false;\r\n  while (!unvisitedHeap.empty()) {\r\n    // get the next most optimal cell according to hCost\r\n    var currentCell = unvisitedHeap.pop();\r\n    if (searchVars.stopSearch) {\r\n      searchVars.stopSearch = false;\r\n      return;\r\n    }\r\n    if (currentCell === endCell) {\r\n      foundPath = true;\r\n      break;\r\n    }\r\n\r\n    // if the next optimal cell we have chosen has not changed in hCost it means there is no path\r\n    if (currentCell.hCost === Number.MAX_SAFE_INTEGER) {\r\n      // needs this break because all cells are given to BFS heap on initialization\r\n      break;\r\n    }\r\n\r\n    if (canCrossDiagonals) {\r\n      neighbours = gridCl.getMooreNeighbours(currentCell.x, currentCell.y);\r\n    } else {\r\n      neighbours = gridCl.getVonNeumannNeighbours(currentCell.x, currentCell.y);\r\n    }\r\n\r\n    // Filter out any opened or closed neighbours\r\n    // The reason we filter out any opened is because BFS will not\r\n    // attempt to recalculate a new distance through the current cell\r\n    // so there is no need to include opened cells for recalculation\r\n    const unVisitedNeighbours = neighbours.filter(\r\n      (x) => !x.closed && !x.opened\r\n    );\r\n\r\n    let tempCurrentCell = currentCell;\r\n\r\n    // for every neighbour assign hCost, parent cell, and update position in heap\r\n    unVisitedNeighbours.forEach((neighbour) => {\r\n      if (neighbour.cellType !== CELL_TYPES.OBSTACLE) {\r\n        neighbour.hCost = gridCl.calculateDistance(\r\n          neighbour,\r\n          endCell,\r\n          canCrossDiagonals\r\n        );\r\n\r\n        neighbour.parentCell = tempCurrentCell;\r\n\r\n        neighbour.opened = true;\r\n        neighbour.setCellRerender((rerender) => !rerender);\r\n\r\n        unvisitedHeap.updateItem(neighbour);\r\n      }\r\n    });\r\n\r\n    // we have now checked the neighbours of the current cell\r\n    currentCell.closed = true;\r\n    currentCell.setCellRerender((rerender) => !rerender);\r\n\r\n    if (searchVars.searchAnimationTime > 0) {\r\n      await timer(searchVars.searchAnimationTime);\r\n    }\r\n  }\r\n\r\n  if (foundPath) {\r\n    const path = retracePath(startCell, endCell);\r\n    return path;\r\n  } else {\r\n    console.log(\"no path found\");\r\n  }\r\n}\r\n\r\n/* Resets the cells to have the maximum hCost before adding them to the heap.\r\n\r\nThis is done so every cell can update its hCost during BFS.\r\n\r\n@param {Heap} heap - the heap to add cells to after hCost reset\r\n@returns {Promise} - resolves the action of reseting hCosts and adding to heap\r\n\r\n*/\r\nfunction initHeap(heap) {\r\n  return new Promise((resolve) =>\r\n    resolve(\r\n      gridCl.grid.forEach((row) =>\r\n        row.forEach((cell) => {\r\n          cell.hCost = Number.MAX_SAFE_INTEGER;\r\n          heap.push(cell);\r\n        })\r\n      )\r\n    )\r\n  );\r\n}\r\n","import { rndEven, rndOdd, timer } from \"../UtilityFuncs\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { cellIsStartOrEnd } from \"../Cell/CellActions\";\r\nimport { CELL_TYPES } from \"../Cell/CellActions\";\r\n\r\n/*Recursive Division\r\n\r\nMaze creation algorithm that recursively seperates the grid into sections.\r\nEach section is seperated by a wall with a single passage.\r\n\r\nThe maze chooses whether to place vertical or horizontal walls in accordance \r\nto each sections dimensions.\r\n*/\r\n\r\nconst ORIENTATIONS = {\r\n  HORIZONTAL: \"HORIZONTAL\",\r\n  VERTICAL: \"VERTICAL\",\r\n};\r\n\r\nexport default function startRecursiveDivision() {\r\n  return new Promise((resolve, reject) => {\r\n    divide(\r\n      1,\r\n      1,\r\n      gridCl.maxX - 2,\r\n      gridCl.maxY - 2,\r\n      chooseOrientation(1, 1, gridCl.maxX - 2, gridCl.maxY - 2)\r\n    )\r\n      .then(() => {\r\n        resolve(\"success\");\r\n      })\r\n      .catch((err) => {\r\n        reject(err);\r\n      });\r\n  });\r\n}\r\n\r\n/* Determines whether to do a horizontal or vertical wall\r\n\r\nhorizontal space is greater than the vertical cut vertically vice-versa\r\n\r\n@param {number} leftBound - the left most bound of the current section\r\n@param {number} upperBound - the upper most bound of the current section\r\n@param {number} rightBound - the right most bound of the current section\r\n@param {number} lowerBound - the lower most bound of the current section\r\n\r\n@return {string} orientation - the orientation of the wall to place\r\n*/\r\nfunction chooseOrientation(leftBound, upperBound, rightBound, lowerBound) {\r\n  const horizSpace = rightBound - leftBound;\r\n  const vertSpace = lowerBound - upperBound;\r\n\r\n  if (horizSpace > vertSpace) {\r\n    return ORIENTATIONS.VERTICAL;\r\n  } else if (vertSpace > horizSpace) {\r\n    return ORIENTATIONS.HORIZONTAL;\r\n  } else {\r\n    return Math.random() > 0.5\r\n      ? ORIENTATIONS.HORIZONTAL\r\n      : ORIENTATIONS.VERTICAL;\r\n  }\r\n}\r\n\r\nconst passageSize = 1;\r\n\r\n/*Recursively divides the grid into sections\r\n\r\nEach section is seperated by a wall with a passage.\r\n\r\n@param {number} leftBound - the left most bound of the current section\r\n@param {number} upperBound - the upper most bound of the current section\r\n@param {number} rightBound - the right most bound of the current section\r\n@param {number} lowerBound - the lower most bound of the current section\r\n\r\n@param {string} orientation - the orientation of the wall to place\r\n*/\r\nasync function divide(\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound,\r\n  orientation\r\n) {\r\n  if (\r\n    rightBound - leftBound <= passageSize ||\r\n    lowerBound - upperBound <= passageSize\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  var isHorizontalCut = orientation === ORIENTATIONS.HORIZONTAL;\r\n\r\n  const { xStartIdx, yStartIdx } = findStart(\r\n    isHorizontalCut,\r\n    leftBound,\r\n    upperBound,\r\n    rightBound,\r\n    lowerBound\r\n  );\r\n\r\n  const { xPassageIdx, yPassageIdx } = choosePassage(\r\n    isHorizontalCut,\r\n    leftBound,\r\n    upperBound,\r\n    rightBound,\r\n    lowerBound\r\n  );\r\n\r\n  var wallDist = isHorizontalCut\r\n    ? rightBound - leftBound\r\n    : lowerBound - upperBound;\r\n\r\n  var dirX = isHorizontalCut ? 1 : 0;\r\n  var dirY = isHorizontalCut ? 0 : 1;\r\n\r\n  await drawWall(\r\n    xStartIdx,\r\n    yStartIdx,\r\n    xPassageIdx,\r\n    yPassageIdx,\r\n    wallDist,\r\n    dirX,\r\n    dirY\r\n  );\r\n\r\n  if (isHorizontalCut) {\r\n    // top section\r\n    await divide(\r\n      leftBound,\r\n      upperBound,\r\n      rightBound,\r\n      yStartIdx - 1,\r\n      chooseOrientation(leftBound, upperBound, rightBound, yStartIdx - 1)\r\n    );\r\n    // bottom section\r\n    await divide(\r\n      leftBound,\r\n      yStartIdx + 1,\r\n      rightBound,\r\n      lowerBound,\r\n      chooseOrientation(leftBound, yStartIdx + 1, rightBound, lowerBound)\r\n    );\r\n  } else {\r\n    // left section\r\n    await divide(\r\n      leftBound,\r\n      upperBound,\r\n      xStartIdx - 1,\r\n      lowerBound,\r\n      chooseOrientation(leftBound, upperBound, xStartIdx - 1, lowerBound)\r\n    );\r\n\r\n    // right section\r\n    await divide(\r\n      xStartIdx + 1,\r\n      upperBound,\r\n      rightBound,\r\n      lowerBound,\r\n      chooseOrientation(xStartIdx + 1, upperBound, rightBound, lowerBound)\r\n    );\r\n  }\r\n}\r\n\r\n/* Draws the wall at a given start point and avoids placing a wall at a given passage point \r\n\r\nThe wall also avoids placing walls where there is a start or end cell\r\n\r\n@param {number} xStartIdx - the x-index in the grid to start drawing the wall\r\n@param {number} yStartIdx - the y-index in the grid to start drawing the wall\r\n@param {number} xPassageIdx - the x-index in the grid to avoid placing a wall\r\n@param {number} yPassageIdx - the y-index in the grid to avoid placing a wall\r\n@param {number} wallDist - the number of cells to draw on\r\n@param {number} dirX - the direction to draw cells on the x-axis\r\n@param {number} dirY - the direction to draw cells on the y-axis\r\n*/\r\nasync function drawWall(\r\n  xStartIdx,\r\n  yStartIdx,\r\n  xPassageIdx,\r\n  yPassageIdx,\r\n  wallDist,\r\n  dirX,\r\n  dirY\r\n) {\r\n  var xWallIdx = xStartIdx;\r\n  var yWallIdx = yStartIdx;\r\n\r\n  for (let i = 0; i <= wallDist; i++) {\r\n    if (\r\n      xWallIdx === xPassageIdx ||\r\n      yWallIdx === yPassageIdx ||\r\n      cellIsStartOrEnd(xWallIdx, yWallIdx)\r\n    ) {\r\n      xWallIdx += dirX;\r\n      yWallIdx += dirY;\r\n      continue;\r\n    }\r\n    gridCl.grid[yWallIdx][xWallIdx].cellType = CELL_TYPES.OBSTACLE;\r\n    gridCl.grid[yWallIdx][xWallIdx].setCellRerender((rerender) => !rerender);\r\n\r\n    xWallIdx += dirX;\r\n    yWallIdx += dirY;\r\n\r\n    await timer(1);\r\n  }\r\n}\r\n\r\n/*Chooses the point to place a passage\r\n\r\nOnly place passages on odd indices so they do not intersect with walls.\r\n\r\n@param {boolean} isHorizontalCut - whether the wall that is being placed is horizontal or not\r\n@param {number} leftBound - the left most bound of the current section\r\n@param {number} upperBound - the upper most bound of the current section\r\n@param {number} rightBound - the right most bound of the current section\r\n@param {number} lowerBound - the lower most bound of the current section\r\n\r\n@return {Object} object containing the x and y indices of the passage\r\n*/\r\nfunction choosePassage(\r\n  isHorizontalCut,\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound\r\n) {\r\n  var xPassageIdx = 0;\r\n  var yPassageIdx = 0;\r\n\r\n  if (isHorizontalCut) {\r\n    xPassageIdx = rndOdd(leftBound, rightBound);\r\n    yPassageIdx = upperBound;\r\n  } else {\r\n    xPassageIdx = leftBound;\r\n    yPassageIdx = rndOdd(upperBound, lowerBound);\r\n  }\r\n\r\n  return { xPassageIdx, yPassageIdx };\r\n}\r\n\r\n/*Finds the starting point to place the wall\r\n\r\nYou want walls to be on even indices so they cannot be created right beside\r\nthe grid outline as it would leave no room for a path.\r\n\r\n@param {boolean} isHorizontalCut - whether the wall that is being placed is horizontal or not\r\n@param {number} leftBound - the left most bound of the current section\r\n@param {number} upperBound - the upper most bound of the current section\r\n@param {number} rightBound - the right most bound of the current section\r\n@param {number} lowerBound - the lower most bound of the current section\r\n\r\n@return {Object} object containing the x and y indices of the wall start\r\n*/\r\nfunction findStart(\r\n  isHorizontalCut,\r\n  leftBound,\r\n  upperBound,\r\n  rightBound,\r\n  lowerBound\r\n) {\r\n  var xStartIdx = 0;\r\n  var yStartIdx = 0;\r\n\r\n  // +1 or -1 so that the start indices leave room for a path between the bound and this current wall.\r\n  // As long as the grid dimensions are odd, using +1 and -1 gives us even numbers which is needed for rndEven()\r\n\r\n  if (isHorizontalCut) {\r\n    xStartIdx = leftBound;\r\n    yStartIdx = rndEven(upperBound + 1, lowerBound - 1);\r\n  } else {\r\n    xStartIdx = rndEven(leftBound + 1, rightBound - 1);\r\n    yStartIdx = upperBound;\r\n  }\r\n\r\n  return { xStartIdx, yStartIdx };\r\n}\r\n","import React, { useReducer, useState } from \"react\";\r\nimport AStarSearch from \"../PathFindingAlgos/AStarAlgorithm\";\r\nimport dijkstrasSearch from \"../PathFindingAlgos/DijkstrasAlgorithm\";\r\nimport breadthFirstSearch from \"../PathFindingAlgos/BreadthFirstSearch\";\r\nimport bestFirstSearch from \"../PathFindingAlgos/BestFirstSearch\";\r\nimport startRecursiveDivision from \"../MazeAlgos/RecursiveDivision\";\r\nimport { searchVars, pathFind } from \"../Search\";\r\nimport { gridCl } from \"../Grid/Grid\";\r\nimport { mazeVars, createMaze } from \"../Maze\";\r\nimport algoReducer, { initialState } from \"../AlgorithmReducer\";\r\nimport { clamp } from \"../UtilityFuncs\";\r\nimport \"./header.css\";\r\n\r\nfunction Header() {\r\n  const [state, dispatch] = useReducer(algoReducer, initialState);\r\n\r\n  const [canCrossDiagonals, setCanCrossDiagonals] = useState(true);\r\n  const [animationInterval, setAnimationInterval] = useState(15);\r\n  const [missingCell, setMissingCell] = useState(false);\r\n\r\n  const executePathFinding = (algorithm) => {\r\n    if (gridCl.startCell != null && gridCl.endCell != null) {\r\n      pathFind(canCrossDiagonals, dispatch, algorithm);\r\n    } else {\r\n      setMissingCell(true);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <section className=\"header\">\r\n      <div className=\"main\">\r\n        <section id=\"click-instructions\">\r\n          <h4>Ctrl Click: set start cell</h4>\r\n          <h4>Alt Click: set end cell</h4>\r\n        </section>\r\n        <div>\r\n          <div className=\"input-with-prepending\">\r\n            <h5>Animation Interval (ms)</h5>\r\n            <input\r\n              value={animationInterval}\r\n              onChange={(evt) => {\r\n                if (evt.target.value !== \"\") {\r\n                  let interval = clamp(\r\n                    parseFloat(evt.target.value),\r\n                    searchVars.minSearchTime,\r\n                    searchVars.maxSearchTime\r\n                  );\r\n                  setAnimationInterval(interval);\r\n                  searchVars.searchAnimationTime = interval;\r\n                }\r\n              }}\r\n              min={searchVars.minSearchTime}\r\n              max={searchVars.maxSearchTime}\r\n              type=\"number\"\r\n            />\r\n          </div>\r\n          <div className=\"input-with-prepending\">\r\n            <h5>Can Cross Diagonals</h5>\r\n            <input\r\n              id=\"diagonals-checkbox\"\r\n              type=\"checkbox\"\r\n              checked={canCrossDiagonals}\r\n              onChange={() =>\r\n                setCanCrossDiagonals((canCrossDiagonals) => !canCrossDiagonals)\r\n              }\r\n            />\r\n            <span className=\"slider round\"></span>\r\n          </div>\r\n        </div>\r\n        <button\r\n          onClick={() => createMaze(startRecursiveDivision, dispatch)}\r\n          className={\r\n            state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n          }\r\n        >\r\n          Create Maze\r\n        </button>\r\n        <section className=\"algorithms\">\r\n          <h4>Pathfinding Algorithms</h4>\r\n          <button\r\n            onClick={() => executePathFinding(AStarSearch)}\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            A*\r\n          </button>\r\n          <button\r\n            onClick={() => executePathFinding(dijkstrasSearch)}\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Dijkstras\r\n          </button>\r\n          <button\r\n            onClick={() => executePathFinding(breadthFirstSearch)}\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Breadth First Search\r\n          </button>\r\n          <button\r\n            onClick={() => executePathFinding(bestFirstSearch)}\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Best First Search\r\n          </button>\r\n        </section>\r\n        <section className=\"clears\">\r\n          <h4>Clearing Options</h4>\r\n          <button\r\n            onClick={() => {\r\n              if (!searchVars.isSearching && !mazeVars.isCreatingMaze) {\r\n                gridCl.clearEntireGrid();\r\n              }\r\n            }}\r\n            className={\r\n              state.isSearching || state.isCreatingMaze ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Clear Entire Grid\r\n          </button>\r\n          <button\r\n            onClick={() => {\r\n              if (!mazeVars.isCreatingMaze && !searchVars.isSearching) {\r\n                gridCl.clearWalls();\r\n              }\r\n            }}\r\n            className={\r\n              state.isCreatingMaze || searchVars.isSearching ? \"disabled\" : \"\"\r\n            }\r\n          >\r\n            Clear Walls\r\n          </button>\r\n          <button\r\n            onClick={() => {\r\n              if (searchVars.isSearching) {\r\n                searchVars.stopSearch = true;\r\n              }\r\n            }}\r\n            type=\"button\"\r\n            className={state.isSearching ? \"\" : \"disabled\"}\r\n          >\r\n            Stop Search\r\n          </button>\r\n        </section>\r\n      </div>\r\n      <div\r\n        className={`notif ${missingCell ? \"appear\" : \"\"}`}\r\n        onClose={() => setMissingCell(false)}\r\n      >\r\n        <div>\r\n          <h4>You are missing a start or end cell</h4>\r\n        </div>\r\n      </div>\r\n    </section>\r\n  );\r\n}\r\n\r\nexport default Header;\r\n","import Grid from \"./Grid/Grid\";\nimport Header from \"./Header/Header\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Header />\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"./reset.css\";\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}